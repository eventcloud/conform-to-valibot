{"version":3,"sources":["../index.ts","../constraint.ts","../parse.ts","../coercion.ts"],"sourcesContent":["export { getValibotConstraint } from \"./constraint\";\nexport { parseWithValibot } from \"./parse\";\n","import type { Constraint } from \"@conform-to/dom\";\nimport type { GenericSchema, GenericSchemaAsync } from \"valibot\";\n\nconst keys: Array<keyof Constraint> = [\n  \"required\",\n  \"minLength\",\n  \"maxLength\",\n  \"min\",\n  \"max\",\n  \"step\",\n  \"multiple\",\n  \"pattern\",\n];\n\nexport function getValibotConstraint<\n  T extends GenericSchema | GenericSchemaAsync,\n>(schema: T): Record<string, Constraint> {\n  function updateConstraint(\n    schema: T,\n\n    data: Record<string, Constraint>,\n    name = \"\",\n  ): void {\n    if (name !== \"\" && !data[name]) {\n      data[name] = { required: true };\n    }\n    const constraint = name !== \"\" ? data[name] : {};\n\n    if (schema.type === \"object\") {\n      // @ts-expect-error\n      for (const key in schema.entries) {\n        updateConstraint(\n          // @ts-expect-error\n          schema.entries[key],\n          data,\n          name ? `${name}.${key}` : key,\n        );\n      }\n    } else if (schema.type === \"intersect\") {\n      // @ts-expect-error\n      for (const option of schema.options) {\n        const result: Record<string, Constraint> = {};\n        updateConstraint(option, result, name);\n\n        Object.assign(data, result);\n      }\n    } else if (schema.type === \"union\" || schema.type === \"variant\") {\n      Object.assign(\n        data,\n        // @ts-expect-error\n        schema.options\n          // @ts-expect-error\n          .map((option) => {\n            const result: Record<string, Constraint> = {};\n\n            updateConstraint(option, result, name);\n\n            return result;\n          })\n          // @ts-expect-error\n          .reduce((prev, next) => {\n            const list = new Set([...Object.keys(prev), ...Object.keys(next)]);\n            const result: Record<string, Constraint> = {};\n\n            for (const name of list) {\n              const prevConstraint = prev[name];\n              const nextConstraint = next[name];\n\n              if (prevConstraint && nextConstraint) {\n                const constraint: Constraint = {};\n\n                result[name] = constraint;\n\n                for (const key of keys) {\n                  if (\n                    typeof prevConstraint[key] !== \"undefined\" &&\n                    typeof nextConstraint[key] !== \"undefined\" &&\n                    prevConstraint[key] === nextConstraint[key]\n                  ) {\n                    constraint[key] = prevConstraint[key];\n                  }\n                }\n              } else {\n                result[name] = {\n                  ...prevConstraint,\n                  ...nextConstraint,\n                  required: false,\n                };\n              }\n            }\n\n            return result;\n          }),\n      );\n    } else if (name === \"\") {\n      // All the cases below are not allowed on root\n      throw new Error(\"Unsupported schema\");\n    } else if (schema.type === \"array\") {\n      constraint.multiple = true;\n      // @ts-expect-error\n      updateConstraint(schema.item, data, `${name}[]`);\n    } else if (schema.type === \"string\") {\n      // @ts-expect-error\n      const minLength = schema.pipe?.find(\n        // @ts-expect-error\n        (v) => \"type\" in v && v.type === \"min_length\",\n      );\n      if (minLength && \"requirement\" in minLength) {\n        constraint.minLength = minLength.requirement as number;\n      }\n      // @ts-expect-error\n      const maxLength = schema.pipe?.find(\n        // @ts-expect-error\n        (v) => \"type\" in v && v.type === \"max_length\",\n      );\n      if (maxLength && \"requirement\" in maxLength) {\n        constraint.maxLength = maxLength.requirement as number;\n      }\n    } else if (schema.type === \"optional\") {\n      constraint.required = false;\n      // @ts-expect-error\n      updateConstraint(schema.wrapped, data, name);\n    } else if (schema.type === \"nullish\") {\n      constraint.required = false;\n      // @ts-expect-error\n      updateConstraint(schema.wrapped, data, name);\n    } else if (schema.type === \"number\") {\n      // @ts-expect-error\n      const minValue = schema.pipe?.find(\n        // @ts-expect-error\n        (v) => \"type\" in v && v.type === \"min_value\",\n      );\n      if (minValue && \"requirement\" in minValue) {\n        constraint.min = minValue.requirement as number;\n      }\n      // @ts-expect-error\n      const maxValue = schema.pipe?.find(\n        // @ts-expect-error\n        (v) => \"type\" in v && v.type === \"max_value\",\n      );\n      if (maxValue && \"requirement\" in maxValue) {\n        constraint.max = maxValue.requirement as number;\n      }\n    } else if (schema.type === \"enum\") {\n      // @ts-expect-error\n      constraint.pattern = Object.entries(schema.enum)\n        .map(([_, option]) =>\n          // To escape unsafe characters on regex\n          typeof option === \"string\"\n            ? option\n              .replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\")\n              .replace(/-/g, \"\\\\x2d\")\n            : option,\n        )\n        .join(\"|\");\n    } else if (schema.type === \"tuple\") {\n      // @ts-expect-error\n      for (let i = 0; i < schema.items.length; i++) {\n        // @ts-expect-error\n        updateConstraint(schema.items[i], data, `${name}[${i}]`);\n      }\n    } else {\n      // FIXME: If you are interested in this, feel free to create a PR\n    }\n  }\n\n  const result: Record<string, Constraint> = {};\n\n  updateConstraint(schema, result);\n\n  return result;\n}\n","import {\n  type Intent,\n  type Submission,\n  parse as baseParse,\n  formatPaths,\n} from \"@conform-to/dom\";\nimport {\n  type BaseIssue,\n  type Config,\n  type GenericSchema,\n  type GenericSchemaAsync,\n  type InferOutput,\n  type SafeParseResult,\n  safeParse,\n  safeParseAsync,\n} from \"valibot\";\nimport { enableTypeCoercion } from \"./coercion\";\n\nexport function parseWithValibot<Schema extends GenericSchema>(\n  payload: FormData | URLSearchParams,\n  config: {\n    schema: Schema | ((intent: string) => Schema);\n    info?: Pick<\n      Config<BaseIssue<unknown>>,\n      \"abortEarly\" | \"abortPipeEarly\" | \"lang\"\n    >;\n  },\n): Submission<InferOutput<Schema>>;\nexport function parseWithValibot<Schema extends GenericSchemaAsync>(\n  payload: FormData | URLSearchParams,\n  config: {\n    schema: Schema | ((intent: string) => Schema);\n    info?: Pick<\n      Config<BaseIssue<unknown>>,\n      \"abortEarly\" | \"abortPipeEarly\" | \"lang\"\n    >;\n  },\n): Promise<Submission<InferOutput<Schema>>>;\nexport function parseWithValibot<\n  Schema extends GenericSchema | GenericSchemaAsync,\n>(\n  payload: FormData | URLSearchParams,\n  config: {\n    schema: Schema | ((intent: Intent | null) => Schema);\n    info?: Pick<\n      Config<BaseIssue<unknown>>,\n      \"abortEarly\" | \"abortPipeEarly\" | \"lang\"\n    >;\n  },\n): Submission<InferOutput<Schema>> | Promise<Submission<InferOutput<Schema>>> {\n  return baseParse<InferOutput<Schema>, string[]>(payload, {\n    resolve(payload, intent) {\n      const originalSchema =\n        typeof config.schema === \"function\"\n          ? config.schema(intent)\n          : config.schema;\n      const schema = enableTypeCoercion(originalSchema);\n\n      const resolveResult = (\n        result: SafeParseResult<Schema>,\n      ):\n        | { value: InferOutput<Schema> }\n        | { error: Record<string, string[]> } => {\n        if (result.success) {\n          return {\n            value: result.output,\n          };\n        }\n\n        return {\n          error: result.issues.reduce<Record<string, string[]>>((result, e) => {\n            const name = e.path\n              ? // @ts-expect-error\n                formatPaths(e.path.map((d) => d.key as string | number))\n              : (e.input as string | number);\n\n            result[name] = [...(result[name] ?? []), e.message];\n\n            return result;\n          }, {}),\n        };\n      };\n\n      if (schema.async === true) {\n        return safeParseAsync(schema, payload, config.info).then(resolveResult);\n      }\n\n      return resolveResult(safeParse(schema, payload, config.info));\n    },\n  });\n}\n","import {\n  type BaseIssue,\n  type GenericSchema,\n  type GenericSchemaAsync,\n  type PipeItem,\n  type SchemaWithPipe,\n  type SchemaWithPipeAsync,\n  pipe,\n  pipeAsync,\n  transform as vTransform,\n  unknown as valibotUnknown,\n} from \"valibot\";\n\n/**\n * Helpers for coercing string value\n * Modify the value only if it's a string, otherwise return the value as-is\n */\nexport function coerceString(\n  value: unknown,\n  transform?: (text: string) => unknown,\n) {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n\n  if (value === \"\") {\n    return undefined;\n  }\n\n  if (typeof transform !== \"function\") {\n    return value;\n  }\n\n  try {\n    return transform(value);\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Reconstruct the provided schema with additional preprocessing steps\n * This coerce empty values to undefined and transform strings to the correct type\n * @param type The schema to be coerced\n * @param transform The transformation function\n * @returns The coerced schema\n */\nfunction coerce<T extends GenericSchema | GenericSchemaAsync>(\n  type: T,\n  transform?: (text: string) => unknown,\n) {\n  // `expects` is required to generate error messages for `TupleSchema`, so it is passed to `UnkonwSchema` for coercion.\n  const unknown = { ...valibotUnknown(), expects: type.expects };\n  const transformFunction = (output: unknown) =>\n    type.type === \"blob\" || type.type === \"file\"\n      ? coerceFile(output)\n      : coerceString(output, transform);\n\n  if (type.async) {\n    return pipeAsync(unknown, vTransform(transformFunction), type);\n  }\n\n  return pipe(unknown, vTransform(transformFunction), type);\n}\n\n/**\n * Helpers for coercing file\n * Modify the value only if it's a file, otherwise return the value as-is\n */\nexport function coerceFile(file: unknown) {\n  if (\n    typeof File !== \"undefined\" &&\n    file instanceof File &&\n    file.name === \"\" &&\n    file.size === 0\n  ) {\n    return undefined;\n  }\n\n  return file;\n}\n\n/**\n * If a pipe is assigned by referencing the original schema, convert it to assign the original pipe to the coerced schema.\n * @param originalSchema The original schema\n * @param coercionSchema The schema to be coerced\n * @returns The coerced schema with the original pipe\n */\nfunction generateReturnSchema<\n  T extends GenericSchema | GenericSchemaAsync,\n  E extends\n    | GenericSchema\n    | GenericSchemaAsync\n    | SchemaWithPipe<\n        [GenericSchema, ...PipeItem<unknown, unknown, BaseIssue<unknown>>[]]\n      >\n    | SchemaWithPipeAsync<\n        [\n          GenericSchema | GenericSchemaAsync,\n          ...PipeItem<unknown, unknown, BaseIssue<unknown>>[],\n        ]\n      >,\n>(\n  originalSchema:\n    | T\n    | (T extends GenericSchema\n        ? SchemaWithPipe<\n            [T, ...PipeItem<unknown, unknown, BaseIssue<unknown>>[]]\n          >\n        : SchemaWithPipeAsync<\n            [T, ...PipeItem<unknown, unknown, BaseIssue<unknown>>[]]\n          >),\n  coercionSchema: E,\n) {\n  if (\"pipe\" in originalSchema) {\n    if (originalSchema.async && coercionSchema.async) {\n      return pipeAsync(\n        coercionSchema,\n        // @ts-expect-error\n        ...originalSchema.pipe.slice(1),\n      );\n    }\n    return pipe(\n      coercionSchema,\n      // @ts-expect-error\n      ...originalSchema.pipe.slice(1),\n    );\n  }\n\n  return coercionSchema;\n}\n\n/**\n * Reconstruct the provided schema with additional preprocessing steps\n * This coerce empty values to undefined and transform strings to the correct type\n */\nexport function enableTypeCoercion<\n  T extends GenericSchema | GenericSchemaAsync,\n>(\n  type:\n    | T\n    | (T extends GenericSchema\n        ? SchemaWithPipe<\n            [T, ...PipeItem<unknown, unknown, BaseIssue<unknown>>[]]\n          >\n        : SchemaWithPipeAsync<\n            [T, ...PipeItem<unknown, unknown, BaseIssue<unknown>>[]]\n          >),\n):\n  | ReturnType<typeof coerce>\n  | ReturnType<typeof generateReturnSchema>\n  | (T extends GenericSchema\n      ? SchemaWithPipe<[T, ...PipeItem<unknown, unknown, BaseIssue<unknown>>[]]>\n      : SchemaWithPipeAsync<\n          [T, ...PipeItem<unknown, unknown, BaseIssue<unknown>>[]]\n        >) {\n  const originalSchema = \"pipe\" in type ? type.pipe[0] : type;\n\n  switch (type.type) {\n    case \"string\":\n    case \"literal\":\n    case \"enum\":\n    case \"undefined\": {\n      return coerce(type);\n    }\n    case \"number\": {\n      return coerce(type, Number);\n    }\n    case \"boolean\": {\n      return coerce(type, (text) => (text === \"on\" ? true : text));\n    }\n    case \"date\": {\n      return coerce(type, (timestamp) => {\n        const date = new Date(timestamp);\n        if (Number.isNaN(date.getTime())) {\n          return timestamp;\n        }\n\n        return date;\n      });\n    }\n    case \"bigint\": {\n      return coerce(type, BigInt);\n    }\n    case \"file\":\n    case \"blob\": {\n      return coerce(type);\n    }\n    case \"array\": {\n      const arraySchema = {\n        ...originalSchema,\n        // @ts-expect-error\n        item: enableTypeCoercion(originalSchema.item),\n      };\n      return generateReturnSchema(type, arraySchema);\n    }\n    case \"optional\":\n    case \"nullish\":\n    case \"nullable\":\n    case \"non_optional\":\n    case \"non_nullish\":\n    case \"non_nullable\": {\n      // @ts-expect-error\n      const wrapSchema = enableTypeCoercion(type.wrapped);\n\n      if (\"pipe\" in wrapSchema) {\n        // `expects` is required to generate error messages for `TupleSchema`, so it is passed to `UnkonwSchema` for coercion.\n        const unknown = { ...valibotUnknown(), expects: type.expects };\n        if (type.async) {\n          return pipeAsync(unknown, wrapSchema.pipe[1], type);\n        }\n        return pipe(unknown, wrapSchema.pipe[1], type);\n      }\n\n      const wrappedSchema = {\n        ...originalSchema,\n        // @ts-expect-error\n        wrapped: enableTypeCoercion(originalSchema.wrapped),\n      };\n\n      return generateReturnSchema(type, wrappedSchema);\n    }\n    case \"union\":\n    case \"intersect\": {\n      const unionSchema = {\n        ...originalSchema,\n        // @ts-expect-error\n        options: originalSchema.options.map((option) =>\n          enableTypeCoercion(option as GenericSchema),\n        ),\n      };\n      return generateReturnSchema(type, unionSchema);\n    }\n    case \"variant\": {\n      const variantSchema = {\n        ...originalSchema,\n        // @ts-expect-error\n        options: originalSchema.options.map((option) =>\n          enableTypeCoercion(option as GenericSchema),\n        ),\n      };\n      return generateReturnSchema(type, variantSchema);\n    }\n    case \"tuple\": {\n      const tupleSchema = {\n        ...originalSchema,\n        // @ts-expect-error\n        items: originalSchema.items.map((option) => enableTypeCoercion(option)),\n      };\n      return generateReturnSchema(type, tupleSchema);\n    }\n    case \"tuple_with_rest\": {\n      const tupleWithRestSchema = {\n        ...originalSchema,\n        // @ts-expect-error\n        items: originalSchema.items.map((option) => enableTypeCoercion(option)),\n        // @ts-expect-error\n        rest: enableTypeCoercion(originalSchema.rest),\n      };\n      return generateReturnSchema(type, tupleWithRestSchema);\n    }\n    case \"object\": {\n      const objectSchema = {\n        ...originalSchema,\n        entries: Object.fromEntries(\n          // @ts-expect-error\n          Object.entries(originalSchema.entries).map(([key, def]) => [\n            key,\n            enableTypeCoercion(def as GenericSchema),\n          ]),\n        ),\n      };\n\n      return generateReturnSchema(type, objectSchema);\n    }\n    case \"object_with_rest\": {\n      const objectWithRestSchema = {\n        ...originalSchema,\n        entries: Object.fromEntries(\n          // @ts-expect-error\n          Object.entries(originalSchema.entries).map(([key, def]) => [\n            key,\n            enableTypeCoercion(def as GenericSchema),\n          ]),\n        ),\n        // @ts-expect-error\n        rest: enableTypeCoercion(originalSchema.rest),\n      };\n\n      return generateReturnSchema(type, objectWithRestSchema);\n    }\n  }\n\n  return coerce(type);\n}\n"],"mappings":"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","names":["schema","result","name","constraint","import_valibot","valibotUnknown","vTransform","baseParse","payload","result"]}